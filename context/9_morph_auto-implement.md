***

# LLM Implementation Guide: Morph Fast Apply

## 1. Your Objective

Your task is to integrate the **Morph Fast Apply** system into a codebase that uses an AI agent for code modification. You will add to existing methods of file editing—such as full-file rewrites or search-and-replace—with a more efficient, accurate, and semantic tool called `edit_file` and refine the prompt so that the agent prefer morph-fast-apply, always use it as default and only use other edit tools as fallback.

This approach will significantly improve the speed and reliability of code edits, minimize merge conflicts, and make changes easier to review and cherry-pick for forks.

## 2. Core Concepts: What is Fast Apply?

Before you begin, understand the problem you are solving.

*   **The Problem:** AI agents that rewrite entire files are slow, expensive, and often lose important context or formatting. Agents that use simple search-and-replace are brittle and frequently fail due to minor differences in whitespace or syntax.
*   **The Solution (Fast Apply):** Instead of rewriting a whole file, the agent generates a small, abbreviated "snippet" of the change. This snippet only contains the new or modified lines, with placeholders for the unchanged code. A specialized AI model (the Morph Apply Model) then intelligently merges this snippet into the original file.

This is analogous to how a human developer uses a smart editor: they focus only on the lines they need to change, not the entire file.

## 3. Implementation Plan & Agent Workflow

To successfully integrate Fast Apply, you must enable the AI agent to follow a structured, multi-step process for every code modification task. Your implementation should facilitate this workflow.

### Phase 1: Analyze and Plan (Search & Read)

Before making any changes, the agent must understand the current state of the code.

1.  **Search:** The agent must first identify the relevant files and code sections related to the user's request. This can be done using codebase search, grep, or similar file-finding tools.
2.  **Read:** Once the target file(s) are identified, the agent **must** read their contents. This provides the necessary context to generate an accurate edit. The content of the file will be used as the `initialCode` for the Morph API call.

Your implementation should ensure the agent has access to tools for searching and reading files from the filesystem.

### Phase 2: Define the `edit_file` Tool

This is the core of your task. You will provide the agent with a new tool named `edit_file`. This tool will be the agent's primary method for modifying code.

You must provide a detailed description and schema for this tool so the agent understands how to use it correctly. Below are the required components and instructions for the tool's definition.

#### Tool Description and Prompting Instructions

This text is critical. It instructs the agent on how to think and what to generate.

```
Use this tool to make an edit to an existing file.

This will be read by a less intelligent model, which will quickly apply the edit. You should make it clear what the edit is, while also minimizing the unchanged code you write.
When writing the edit, you should specify each edit in sequence, with the special comment // ... existing code ... to represent unchanged code in between edited lines.

For example:

// ... existing code ...
FIRST_EDIT
// ... existing code ...
SECOND_EDIT
// ... existing code ...
THIRD_EDIT
// ... existing code ...

You should still bias towards repeating as few lines of the original file as possible to convey the change.
But, each edit should contain minimally sufficient context of unchanged lines around the code you're editing to resolve ambiguity.
DO NOT omit spans of pre-existing code (or comments) without using the // ... existing code ... comment to indicate its absence. If you omit the existing code comment, the model may inadvertently delete these lines.
If you plan on deleting a section, you must provide context before and after to delete it. If the initial code is ```code \n Block 1 \n Block 2 \n Block 3 \n code```, and you want to remove Block 2, you would output ```// ... existing code ... \n Block 1 \n  Block 3 \n // ... existing code ...```.
Make edits to a file in a single edit_file call instead of multiple edit_file calls to the same file. The apply model can handle many distinct edits at once.
```

#### Tool Parameters

The tool must accept the following three parameters:

*   `target_file` (string, required): The path to the file that needs to be modified.
*   `instructions` (string, required): A single sentence, **generated by the agent itself**, describing the change in the first person. This helps the apply model resolve ambiguity. Example: `"I am adding async/await error handling to the login function."`
*   `code_edit` (string, required): The abbreviated code snippet representing the change. This snippet **must** use `// ... existing code ...` (or the equivalent comment syntax for the target language) to represent unchanged sections of the file.

#### Example Tool Schema (JSON for Claude-style models)

```json
{
  "name": "edit_file",
  "description": "Use this tool to make an edit to an existing file.\n\nThis will be read by a less intelligent model, which will quickly apply the edit. You should make it clear what the edit is, while also minimizing the unchanged code you write.\nWhen writing the edit, you should specify each edit in sequence, with the special comment // ... existing code ... to represent unchanged code in between edited lines.\n\nFor example:\n\n// ... existing code ...\nFIRST_EDIT\n// ... existing code ...\nSECOND_EDIT\n// ... existing code ...\nTHIRD_EDIT\n// ... existing code ...\n\nYou should still bias towards repeating as few lines of the original file as possible to convey the change.\nBut, each edit should contain minimally sufficient context of unchanged lines around the code you're editing to resolve ambiguity.\nDO NOT omit spans of pre-existing code (or comments) without using the // ... existing code ... comment to indicate its absence. If you omit the existing code comment, the model may inadvertently delete these lines.\nIf you plan on deleting a section, you must provide context before and after to delete it. If the initial code is ```code \\n Block 1 \\n Block 2 \\n Block 3 \\n code```, and you want to remove Block 2, you would output ```// ... existing code ... \\n Block 1 \\n  Block 3 \\n // ... existing code ...```.\nMake sure it is clear what the edit should be, and where it should be applied.\nMake edits to a file in a single edit_file call instead of multiple edit_file calls to the same file. The apply model can handle many distinct edits at once.",
  "input_schema": {
    "type": "object",
    "properties": {
      "target_file": {
        "type": "string",
        "description": "Name or path of target file to modify."
      },
      "instructions": {
        "type": "string",
        "description": "A single sentence instruction describing what you are going to do for the sketched edit. This is used to assist the less intelligent model in applying the edit. Use the first person to describe what you are going to do. Use it to disambiguate uncertainty in the edit."
      },
      "code_edit": {
        "type": "string",
        "description": "Specify ONLY the precise lines of code that you wish to edit. NEVER specify or write out unchanged code. Instead, represent all unchanged code using the comment of the language you're editing in - example: // ... existing code ..."
      }
    },
    "required": ["target_file", "instructions", "code_edit"]
  }
}
```

### Phase 3: Implement the Tool's Execution Logic (Edit)

When the agent invokes the `edit_file` tool, your code must perform the following actions:

1.  **Read Original File Content:** Read the full content of the `target_file`. This is the `initialCode`.
2.  **Call the Morph API:** Make a request to the Morph API endpoint. The request body must contain the `instructions` from the agent, the `initialCode` you just read, and the `code_edit` snippet from the agent.

**API Call Structure:**
The `content` of the user message must be a string formatted with three distinct blocks:

```xml
<instruction>{instructions_from_agent}</instruction>
<code>{full_original_code_from_file}</code>
<update>{code_edit_snippet_from_agent}</update>
```

**Available Models:**
You can specify one of the following models in your API call:
* `morph-v3-fast`
* `morph-v3-large`
* `auto`

**Example Implementation (Python):**

```python
import os
from openai import OpenAI

# Configure the client to point to the Morph API
client = OpenAI(
    api_key=os.getenv("MORPH_API_KEY"),
    base_url="https://api.morphllm.com/v1"
)

def execute_edit_file(target_file: str, instructions: str, code_edit: str):
    # Step 1: Read original file content
    with open(target_file, 'r') as f:
        initial_code = f.read()

    # Step 2: Call the Morph API
    response = client.chat.completions.create(
        model="morph-v3-large",
        messages=[
            {
                "role": "user",
                "content": f"<instruction>{instructions}</instruction>\n<code>{initial_code}</code>\n<update>{code_edit}</update>"
            }
        ]
    )
    
    merged_code = response.choices[0].message.content
    
    # Step 3 (from Phase 4): Write the result
    with open(target_file, 'w') as f:
        f.write(merged_code)
    
    return f"Successfully applied edit to {target_file}."
```

### Phase 4: Handle the Response

- **Write the Result:** The Morph API response will contain the fully merged code in `response.choices[0].message.content`. Your code must take this new content and write it back to the `target_file`, overwriting the original.

## 4. Best Practices for Generating High-Quality Edits

To ensure the highest success rate, the agent must be guided to generate high-quality inputs for the `edit_file` tool.

#### Crafting `code_edit` Snippets

*   **Use Placeholders:** Always use `// ... existing code ...` for unchanged sections.
*   **Provide Context:** Include a few lines of unchanged code before and after the change to help the model find the exact location.
*   **Deleting Code:** To delete a block of code, show the lines *before* and *after* the block you want to remove, with nothing in between.
*   **Adding Imports:** Show the last existing import and the new import you are adding.
*   **Single, Comprehensive Edits:** Encourage the agent to make all necessary changes to a single file in one `edit_file` call. The apply model can handle multiple distinct changes within one snippet.

#### Common Edit Patterns

Here are examples of well-formed `code_edit` snippets for the agent to emulate:

**Adding error handling:**
```javascript
// ... existing code ...
function divide(a, b) {
  if (b === 0) {
    throw new Error("Cannot divide by zero");
  }
  return a / b;
}
// ... existing code ...
```

**Deleting a section:** (Assume a function `function removeThis() {}` existed between the two kept functions)
```javascript
// ... existing code ...
function keepThis() {
  return "stay";
}

function alsoKeepThis() {
  return "also stay";
}
// ... existing code ...
```

## 5. Advanced Method: Using XML for Tool Calls

For superior performance, you should instruct the agent to use XML-formatted tool calls instead of JSON. XML allows the model more cognitive freedom, is more tolerant of minor errors, and often leads to higher-quality code generation.

**1. Update System Prompt:**
Configure the agent's system prompt to expect XML tools.

```text
You are an expert coding assistant. When making code changes, use XML tool calls in this format:

<tool_name>
<parameter_name>parameter_value</parameter_name>
<code>
actual code content here
</code>
</tool_name>

Focus on code quality and correctness. Don't worry about XML formatting - just ensure the content within tags is accurate and helpful.
```

**2. Example XML Tool Call:**
The agent's output would then look like this, which you would parse to execute the tool.

```xml
<edit_file>
<target_file>src/utils/api.ts</target_file>
<instructions>I will add comprehensive error handling with retry logic</instructions>
<code_edit>
// ... existing code ...
export async function apiCall(endpoint: string, options?: RequestInit) {
  const maxRetries = 3;
  let lastError: Error;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
// ... existing code ...
</code_edit>
</edit_file>
```

**3. Parsing:**
You will need to implement a parser (e.g., using regex or a lightweight XML library) to extract the tool name and parameter values from the agent's XML output.
